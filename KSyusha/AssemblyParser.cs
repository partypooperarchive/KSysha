/*
 * Created by SharpDevelop.
 * User: User
 * Date: 31.10.2021
 * Time: 13:21
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
using System.IO;
using Mono.Cecil;

namespace KSyusha
{
	/// <summary>
	/// Description of AssemblyParser.
	/// </summary>
	public class AssemblyParser
	{
		private AssemblyDefinition assembly = null;

		private TypedefResolver td_resolver = null;
		
		private HashSet<string> disabled_derivation_classes = null;
		
		//private IDictionary<string, IEnumerable<string>> parsed_types = null;
		
		private int level = 0;
		
		private Queue<TypeReference> types_to_parse = null;
		
		private HashSet<string> parsed_types = null;
		
		private HashSet<string> mapped_types = null;
		
		private List<string> extra_types = null;
		
		private List<string> extra_enums = null;
		
		private const string aux_prefix = "aux_types";
		
		private const string varuint_type_name = aux_prefix + "::vlq_base128_le_u";
		
		private const string varint_type_name = aux_prefix + "::vlq_base128_le_s";
		
		private bool parsing_excel_class = false;
		
		private const string lpbf_type_name = aux_prefix + "::length_prefixed_bitfield";
		
		private const string error_type_name = aux_prefix + "::error";
		
		public AssemblyParser(string filename)
		{			
			var resolver = new DefaultAssemblyResolver();
			resolver.AddSearchDirectory(Path.GetDirectoryName(filename));
			
			assembly = AssemblyDefinition.ReadAssembly(filename, new ReaderParameters { AssemblyResolver = resolver });
			
			td_resolver = new TypedefResolver(assembly);
			
			disabled_derivation_classes = new HashSet<string>();
			
			parsed_types = new HashSet<string>();
			
			mapped_types = new HashSet<string>();
			
			LoadConfigClasses();
			
			extra_types = new List<string>();
			
			extra_enums = new List<string>();
			
			WriteLine("Assembly {0} loaded", assembly);
		}
		
		private void LoadConfigClasses() {
			#if true
			// Put ExcelConfig classes first
			types_to_parse = new Queue<TypeReference>(
				assembly.MainModule.Types.Where(t => IsExcelConfigClass(t)).Concat(
														assembly.MainModule.Types.Where(t =>
			                                                                          t.FullName.StartsWith("MoleMole.Config.") && 
			                                                                          !IsExcelConfigClass(t) &&
			                                                                          !t.IsInterface &&
			                                                                          !t.HasGenericParameters)
			                                                                         //.Take(1000)
			                                                                        )
			    );
			#else
			types_to_parse = new Queue<TypeReference>(
				assembly.MainModule.Types.Where(t => 
				                                IsExcelConfigClass(t)
				                               ).Concat(td_resolver.GetRegisteredTypes())
			);
			#endif
		}
		
		private bool IsExcelConfigClass(TypeReference t) {
			if (t.FullName.StartsWith("MoleMole.Config.")) { 
				if (t.FullName.EndsWith("ExcelConfig"))
					return true;
				
				// Not all ExcelConfig classes end with "ExcelConfig" suffix, sadly...
				// But there's always a `*Loader` class for them
				var loader_name = string.Format("{0}Loader", t.FullName.Split('.').Last());
				return assembly.MainModule.Types.Any(tt => tt.Name.Split('.').Last().Equals(loader_name));
			}
			
			return false;
		}
		
		public void SetDerivationEnabled(string class_name, bool mode) {
			if (mode) {
				disabled_derivation_classes.Remove(class_name);
			} else {
				disabled_derivation_classes.Add(class_name);
			}
		}
		
		public void Parse() {	
			var roots = td_resolver.GetRootTypes();
			
			foreach (var root in roots) {
				KSBuiltTypeTree(root);
			}
			
			while (types_to_parse.Count > 0) {
				var type = types_to_parse.Dequeue();
				
				parsing_excel_class = IsExcelConfigClass(type);
				
				KSParseType(type);
				
				parsed_types.Add(type.FullName);
			}
		}
		
		public void Dump(string filename) {
			StreamWriter w = new StreamWriter(filename);
			
			var lines = new List<string> {
				"meta:",
				"  id: yuanshen_config_types",
				"  endian: le",
				"  application: YuanShen / Genshin Impact",
				"  license: AGPL-3.0-or-later",
				"  imports:",
				string.Format("    - {0}", aux_prefix),
				"doc: |",
				"  This is an autogenerated file that contains definitions required for parsing the data",
				"  of the YuanShen / Genshin Impact game.",
				"types:",
			};
			
			lines.AddRange(extra_types);
			
			lines.Add("enums:");
			
			lines.AddRange(extra_enums);
			
			foreach (var line in lines) {
				w.WriteLine(line);
			}
			
			w.Close();
		}
		
		#if false
		public string _ParseFile(string filename, string classname, string mode) {
			var cls = td_resolver.FindClassByPrefixedName(classname);
			
			if (cls == null) {
				throw new InvalidDataException(string.Format("Class {0} not found!", classname));
			}
			
			WriteLine("Parsing file {0} for class {1} in {2} mode", filename, cls.FullName, mode);
				
			var reader = new DeReader(filename);
			
			var multiple = !mode.Equals("s");
			
			if (multiple) {			
				ulong length = 0;
				
				if (mode[0] == 'l')
					length = reader.ReadVarUInt();
				else
					length = 1;
				
				WriteLine("Number of elements in file: {0}", length);
			
				var items = new List<string>();
				
				var string_key = assembly.MainModule.ImportReference(typeof(string));
			
				if (mode.Equals("ld")) {
					for (uint i = 0; i < length; i++) {
						items.Add(ParseDictionary(reader, string_key, cls));
					}
			
					return "[" + string.Join(",", items) + "]";
				} else if (mode.Equals("l")) {
					for (uint i = 0; i < length; i++) {
						items.Add(ParseClass(cls, reader));
					}
			
					return "[" + string.Join(",", items) + "]";
				} else if (mode.Equals("d")) {
					return ParseDictionary(reader, string_key, cls);
				} else if (mode.Equals("dl")) {
					var arr_value = assembly.MainModule.ImportReference(new ArrayType(cls));
					return ParseDictionary(reader, string_key, arr_value);
				} else {
					throw new InvalidDataException(string.Format("Invalid mode {0}", mode));
				}
			} else {
				return ParseClass(cls, reader);
			}
		}
		#endif
		
		private string KSParseArray(TypeReference arr_type, TypeReference e_type) {
			var e_type_name = KSParseType(e_type);
			
			var is_array_length_unsigned = !parsing_excel_class || IsUnsignedCount(e_type);
			
			var t_name = string.Format("ks__array_of__{0}__length_{1}", e_type_name, is_array_length_unsigned ? "u" : "s").Replace("::", "__");
			
			if (!parsed_types.Contains(t_name)) { // TODO: we use formatted name here!
				var lines = new List<string>();
				
				lines.Add(string.Format("  {0}:", t_name));
				lines.Add("    seq:");
				
				lines.Add("      - id: length");
				lines.Add(string.Format("        type: {0}", is_array_length_unsigned ? varuint_type_name : varint_type_name));
				lines.Add("      - id: data");
				lines.Add(string.Format("        type: {0}", e_type_name));
				lines.Add("        repeat: expr");
				lines.Add("        repeat-expr: length.value");
					
				extra_types.AddRange(lines);
				
				parsed_types.Add(t_name);
				
				if (!parsed_types.Contains(e_type.FullName))
					KSParseType(e_type);
			}

			return t_name;
		}
		
		private string KSParseDictionary(TypeReference t) {
			var dt = t as GenericInstanceType;
			var key_type = dt.GenericArguments[0];
			var value_type = dt.GenericArguments[1];
			
			var k_name = KSParseType(key_type);
			var v_name = KSParseType(value_type);
			
			var dict_type_name = string.Format("ks__dict_of__{0}_{1}", k_name, v_name).Replace("::", "__");
			var kvp_type_name = string.Format("ks__kvp_of_dict__{0}_{1}", k_name, v_name).Replace("::", "__");
			
			if (!parsed_types.Contains(dict_type_name)) { // TODO: we use formatted name here!
				var lines = new List<string>();
				// Create new <key, value> pair type	
				lines.Add(string.Format("  {0}:", kvp_type_name));
				lines.Add("    seq:");		

				lines.Add("      - id: key");
				lines.Add(string.Format("        type: {0}", k_name));

				lines.Add("      - id: value");
				lines.Add(string.Format("        type: {0}", v_name));
			
				if (!parsed_types.Contains(key_type.FullName))
					KSParseType(key_type);
				
				if (!parsed_types.Contains(value_type.FullName))
					KSParseType(value_type);
				
				// Create new dict type
				lines.Add(string.Format("  {0}:", dict_type_name));
				lines.Add("    seq:");
				
				lines.Add("      - id: length");
				lines.Add(string.Format("        type: {0}", varuint_type_name));
				
				lines.Add("      - id: items");
				lines.Add(string.Format("        type: {0}", kvp_type_name));
				lines.Add("        repeat: expr");
				lines.Add("        repeat-expr: length.value");
				
				extra_types.AddRange(lines);
				
				parsed_types.Add(dict_type_name);
			}
			
			return dict_type_name;
		}
		
		private string KSParseClass(TypeReference t) {		
			bool enable_dispatch = IsPartOfHierarchy(t) && !IsTopOfHierarchy(t);
			
			string t_name = KSGetTypeName(t, enable_dispatch); // Dispatch should only be used in case of class that can be overloaded			
			
			if (!parsed_types.Contains(t.FullName)) {
				// May return other class name (base of the hierarchy)
				KSParseClassWithDerivation(t);
				parsed_types.Add(t.FullName);
			}
			
			return t_name;
		}
		
		private void KSBuiltTypeTree(TypeReference root)
		{
			if (!mapped_types.Contains(root.FullName)) {
				var lines = new List<string>();
					
				lines.Add(string.Format("  {0}:", KSGetTypeName(root, true)));
				lines.Add("    seq:");
				lines.Add("      - id: type_code");
				lines.Add(string.Format("        type: {0}", varuint_type_name));
				lines.Add("      - id: data");
				lines.Add("        type:");
				lines.Add("          switch-on: type_code.value");
				lines.Add("          cases:");
					
				var cases = new List<string>();
					
				for (int i = 0; i < 1024; i++) {
					var cls = td_resolver.FindClassById(root.FullName, i);
						
					if (cls == null)
						break;
						
					cases.Add(string.Format("            {0}: {1}", i, KSGetTypeName(cls)));
				}
					
				if (cases.Count > 0) {
					cases.Add(string.Format("            _: {0}", error_type_name));						
					extra_types.AddRange(lines);						
					extra_types.AddRange(cases);
				}
					
				mapped_types.Add(root.FullName);
			}
		}
		
		private void KSParseClassWithDerivation(TypeReference t) {			
			TypeReference root_class = td_resolver.GetBasestBase(t);
			
			if (root_class == null)
				root_class = t;
			
			KSParseClassInt(t, root_class.FullName);
		}
		
		private List<string> KSParseClassInt(TypeReference t, string hier_bottom_class_name) {					
			List<string> parent_fields_list = null;
			
			HashSet<string> field_list = new HashSet<string>();
			
			var t_name = KSGetTypeName(t);
			
			var parsed = parsed_types.Contains(t.FullName);
			
			var tr = t.Resolve();
			
			string base_name = null;
			
			if (hier_bottom_class_name != null && !tr.FullName.Equals(hier_bottom_class_name) && tr.BaseType != null && !tr.BaseType.FullName.Equals(typeof(object).FullName)) {
				parent_fields_list = KSParseClassInt(tr.BaseType, hier_bottom_class_name);
				base_name = KSGetTypeName(tr.BaseType);
			}
			
			ItemReference[] fields = null;
			
			if (parsing_excel_class) {
				fields = RearrangeProperties(GetAllProperties(tr)).ToArray();
			} else {
				fields = GetAllFields(tr).ToArray();
			}
			
			var lines = new List<string>();
			
			if (!parsed) {
				parsed_types.Add(t.FullName);
				
				lines.Add(string.Format("  {0}:", t_name));
				
				var seq = new List<string>();
			
				WriteLine("Parsing Class {0} ({1} fields)", t.FullName, fields.Length);
			
				//var hashes = new HashSet<string>();
				
				// There're three possible bitmask modes:
				// 1. Length-prefixed bitfield. In this case bitmask is an array of bytes prefixed by length.
				// 2. Big bitfield. Just a regular varint.
				// 3. Small bitfield. Just an unsigned byte
				// Which mode do we use? Depends on the root class we're parsing:
				// a) If we started from `ExcelConfig` class, use first mode;
				// b) Otherwise, use last two modes (3 is used when number of fields <= 8)				
			
				bool small_varint_bitfield = fields.Length <= 8;
				
				if (base_name != null) {
					seq.Add("      - id: ks__base");
					seq.Add(string.Format("        type: {0}", base_name));
				}
				
				if (fields.Length > 0 || parsing_excel_class) {
					var bf_type_name = parsing_excel_class ? lpbf_type_name : (small_varint_bitfield ? "u1" : varuint_type_name);
					
					seq.Add("      - id: ks__bit_field");
					seq.Add(string.Format("        type: {0}", bf_type_name));
				}
				
				// Our own fields
				foreach (var f in fields) {		
					var ft = f.ItemType;

					var f_name = TransformName(f.Name).Transform();
					var f_name_hs = TransformName(f.Name, true).Transform();
					var f_t_name = KSParseType(ft);
				
					seq.Add(string.Format("      - id: {0}", f_name));
					seq.Add(string.Format("        type: {0}", f_t_name));
					seq.Add(string.Format("        if: ks__has_field_{0}", f_name_hs));
					
					if (!parsed_types.Contains(ft.FullName))
						KSParseType(ft);
				}
				
				if (seq.Count > 0) {
					lines.Add("    seq:");
					lines.AddRange(seq);
				} else {
					lines.Add("    seq: []");
				}
				
				var instances = new List<string>();
				
				// Bitmask markers for our fields
				
				for (int i = 0, j = 0; i < fields.Length && j < fields.Length; i++) {
					var f = fields[i];
					// HACK: two hash fields are treated like one
					if (!f.Name.EndsWith("HashSuffix")) {
						var f_name_hs = TransformName(f.Name, true).Transform();
					
						instances.Add(string.Format("      ks__has_field_{0}: # Field №{1}", f_name_hs, j));
						
						if (parsing_excel_class) {
							int b = Hack_MapBit(j, t.FullName.Split('.').Last());
							
							if (b < 0) {
								instances.Add("        value: false");
							} else {
								instances.Add(string.Format("        value: (ks__bit_field.length.value >= (0b{0} + 1)) and ((ks__bit_field.bitfield[0b{0}] & 0b{1}) != 0)",
							                            Convert.ToString(     (b / 8), 2).PadLeft(8, '0'),
							                            Convert.ToString(1 << (b % 8), 2).PadLeft(8, '0')
							                           ));
							}
						} else {
							instances.Add(string.Format("        value: (ks__bit_field{0} & 0b{1}) != 0",
					                            small_varint_bitfield ? "" : ".value",
					                            //Convert.ToString(1 << j, 2).PadLeft(fields.Length, '0')
					                            "1".PadRight(j+1, '0').PadLeft(fields.Length, '0') // Too lazy to do 64-bit shifts
					                           ));
						}
						
						field_list.Add(f_name_hs);
						j++;
					}
				}
				
				// Proxy base class fields
				if (parent_fields_list != null && parent_fields_list.Count > 0) {
					instances.Add("      # Base class fields");
					foreach (var field in parent_fields_list) {
						instances.Add(string.Format("      {0}:", field));
						instances.Add(string.Format("        value: ks__base.{0}", field));
						field_list.Add(field);
					}
				}
				
				if (instances.Count > 0) {
					lines.Add("    instances:");
					lines.AddRange(instances);
				} else {
					lines.Add("    instances: {}");
				}
			} else {
				// Just build field list				
				foreach (var field in fields) {
					field_list.Add(TransformName(field.Name, true).Transform());
				}
				
				if (base_name != null) {
					// Proxy base class fields
					foreach (var field in parent_fields_list) {
						field_list.Add(field);
					}
				}
			}
			
			extra_types.AddRange(lines);
			
			return field_list.ToList();
		}
		
		private string KSParseType(TypeReference t) {
			string t_name = null; //GetKSTypeName(t);
			
			var parsed = parsed_types.Contains(t.FullName);
							
			if (t.IsArray) {
				var arr = t as ArrayType;
				var e_type = arr.ElementType;
				t_name = KSParseArray(t, e_type);
			} else if (t.Resolve().IsEnum) {
				t_name = KSParseEnum(t);
			} else if (t.FullName.Equals(typeof(string).FullName)) {
				t_name = string.Format("{0}::string", aux_prefix);
			} else if (t.FullName.Equals(typeof(uint).FullName)) {
				t_name = varuint_type_name;
			} else if (t.FullName.Equals(typeof(Int64).FullName)) {
				t_name = varint_type_name;
			} else if (t.FullName.Equals(typeof(Int32).FullName) || t.FullName.EndsWith("SimpleSafeInt32")) {
				t_name = varint_type_name;
			} else if (t.FullName.Equals(typeof(Int16).FullName) || t.FullName.EndsWith("SimpleSafeInt16")) {
				t_name = varint_type_name;
			} else if (t.FullName.Equals(typeof(UInt64).FullName)) {
				t_name = varuint_type_name;
			} else if (t.FullName.Equals(typeof(UInt32).FullName) || t.FullName.EndsWith("SimpleSafeUInt32")) {
				t_name = varuint_type_name;
			} else if (t.FullName.Equals(typeof(UInt16).FullName) || t.FullName.EndsWith("SimpleSafeUInt16")) {
				t_name = varuint_type_name;
			} else if (t.FullName.Equals(typeof(byte).FullName)) {
				t_name = "s1";
			} else if (t.FullName.EndsWith("SimpleSafeUInt8")) {
				t_name = "u1";
			} else if (t.FullName.Equals(typeof(bool).FullName) || t.FullName.EndsWith("FixedBool")) {
				t_name = "u1"; // TODO: not bool!
			} else if (t.FullName.Equals(typeof(Single).FullName) || t.FullName.EndsWith("SimpleSafeFloat")) {
				t_name = "f4";
			} else if (t.FullName.Equals(typeof(Double).FullName)) {
				t_name = "f8";
			} else if (t.FullName.EndsWith("DynamicFloat")) {
				t_name = string.Format("{0}::dynamic_float", aux_prefix); // TODO: describe it!
			} else if (t.FullName.EndsWith("DynamicInt")) {
				t_name = string.Format("{0}::dynamic_int", aux_prefix); // TODO: describe it!
			} else if (t.FullName.EndsWith("DynamicArgument")) {
				t_name = string.Format("{0}::dynamic_argument", aux_prefix); // TODO: describe it!
			} else if (t.FullName.EndsWith("DynamicString")) {
				t_name = string.Format("{0}::dynamic_string", aux_prefix); // TODO: describe it!
			} else if (t.FullName.StartsWith("MoleMole.Config.")) {
				t_name = KSParseClass(t.Resolve());
			} else if (t.Name.EndsWith("HashSet`1")) {
				// Treat it as an array
				var dt = t as GenericInstanceType;
				var e_type = dt.GenericArguments[0];
				t_name = KSParseArray(t, e_type);
			} else if (t.Name.EndsWith("Dictionary`2")) {
				t_name = KSParseDictionary(t);
			} else if (t.FullName.EndsWith("*")) {
				t_name = "u1 # TODO: pointer types are not supported!";
			} else {
				throw new InvalidOperationException(string.Format("Type {0} is not supported", t.FullName));
			}
			
			return t_name;
		}
		
		private string KSParseEnum(TypeReference t) {
			var enum_type_name = t.Name.Transform();
			var wrapper_type_name = string.Format("ks__enum__{0}", enum_type_name);
			
			string underlying_type_name = null;
			
			if (!parsed_types.Contains(t.FullName)) {
				// We need to build two types: actual KS enum and a wrapper around it
				
				// Build enum
				var enum_lines = new List<string>();
					
				enum_lines.Add(string.Format("  {0}:", enum_type_name));
					
				foreach (var field in t.Resolve().Fields) {
					if (field.Name != "value__") {
						enum_lines.Add(string.Format("    {0}: {1}", field.Constant, field.Name.Transform()));
					}
				}
					
				extra_enums.AddRange(enum_lines);
				
				// Build type
				var type_lines = new List<string>();
				
				if (IsEnumSigned(t.Resolve()))
					underlying_type_name = varint_type_name;
				else
					underlying_type_name = varuint_type_name;
				
				type_lines.Add(string.Format("  {0}:", wrapper_type_name));
				type_lines.Add("    seq:");
				type_lines.Add("      - id: data");
				type_lines.Add(string.Format("        type: {0}", underlying_type_name));
				type_lines.Add("    instances:");
				type_lines.Add("      value:");
				type_lines.Add("        value: data.value");
				type_lines.Add(string.Format("        enum: {0}", enum_type_name));
				
				extra_types.AddRange(type_lines);
				
				parsed_types.Add(t.FullName);
			}
			
			return wrapper_type_name;
		}
		
		/*
		private string ReadDynamicArgument(DeReader reader) {
			// Credit goes to Raz
			var type_index = reader.ReadVarUInt();
			switch (type_index) {
				case 1:
					return reader.ReadS8().ToString();
				case 2:
					return reader.ReadU8().ToString();
				case 3:
					return reader.ReadS16().ToString();
				case 4:
					return reader.ReadU16().ToString();
				case 5:
					return reader.ReadS32().ToString();
				case 6:
					return reader.ReadU32().ToString();
				case 7:
					return reader.ReadF32().ToString(nfi);
				case 8:
					return reader.ReadF64().ToString(nfi);
				case 9:
					return reader.ReadBool().ToString().ToLower();
				case 10:
					return "\"" + reader.ReadString() + "\"";
				default:
					throw new InvalidDataException(string.Format("Unhandled DynamicArgument type {0}!", type_index));
			}
		}
		
 		private string ReadDynamicInt(DeReader reader) {
			// Credit goes to Raz
			bool isString = reader.ReadBool();
			
			if (isString) {
				return "\"" + reader.ReadString() + "\"";
			} else {
				return reader.ReadVarInt().ToString();
			}
		}
		
		private string ReadDynamicFloat(DeReader reader) {
			// Credit goes to Raz
			bool isFormula = reader.ReadBool();
			
			if (isFormula) {
				long count = reader.ReadVarInt();
				
				var components = new List<string>();
				
				for (int i = 0; i < count; i++) {
					bool isOperator = reader.ReadBool();
					
					if (isOperator) {
						long op = reader.ReadVarInt();
						string s_op = td_resolver.GetDynamicFloatOperator(op);
						components.Add("\"" + s_op + "\"");
					} else {
						bool isString = reader.ReadBool();
						
						if (isString) {
							string s = reader.ReadString();
							components.Add("\"" + s + "\"");
						} else {
							float f = reader.ReadF32();
							components.Add(f.ToString(nfi));
						}
					}
				}
				
				return "[" + string.Join(",", components) + "]"; 
			} else {
				bool isString = reader.ReadBool();
						
				if (isString) {
					string s = reader.ReadString();
					return "\"" + s + "\"";
				} else {
					float f = reader.ReadF32();
					return f.ToString(nfi);
				}
			}
			
			throw new DivideByZeroException("You fucked up");
		}
		*/
		
		private bool IsUnsignedCount(TypeReference t) {
			return t.FullName.Equals(typeof(string).FullName) ||
			    t.FullName.Equals(typeof(uint).FullName) ||
				t.FullName.Equals(typeof(Int64).FullName) ||
				t.FullName.Equals(typeof(Int32).FullName) ||
				t.FullName.Equals(typeof(UInt16).FullName) ||
			    t.FullName.Equals(typeof(byte).FullName) ||
			    t.FullName.Equals(typeof(bool).FullName) ||
				t.FullName.Equals(typeof(Single).FullName) ||
			    t.FullName.EndsWith("SimpleSafeFloat") || 
			    t.FullName.EndsWith("SimpleSafeUInt32") ||
				t.FullName.EndsWith("SimpleSafeUInt16") ||
				t.FullName.EndsWith("SimpleSafeInt32") ||
				t.FullName.EndsWith("MoleMole.Config.ElementType") ||
				(t.Resolve().IsEnum && !IsEnumSigned(t.Resolve())) ||
				t.IsArray;
		}
		
		private bool IsEnumSigned(TypeDefinition t) {		
			foreach (var field in t.Fields) {
				if (field.Name == "value__") {
					var n = field.FieldType.FullName;
					// Possible underlying types: byte, sbyte, short, ushort, int, uint, long, ulong
					return (
						n.Equals(typeof(sbyte).FullName) ||
						n.Equals(typeof(short).FullName) ||
						n.Equals(typeof(int).FullName) ||
						n.Equals(typeof(long).FullName)
					);
				}
			}
			
			throw new ArgumentException("Unable to determine signedness of enum {0}!", t.FullName);
		}
		
		private string TransformName(string name, bool transform_hashes = false) {
			if (name.StartsWith("_"))
				name = name.TrimStart('_'); //name.Substring(1);
			
			if (char.IsLower(name[0]))
				name = char.ToUpper(name[0]) + name.Substring(1);
			
			if (name.EndsWith("RawNum"))
				name = name.Substring(0, name.Length - "RawNum".Length);
			
			if (name.EndsWith("TextMapHash"))
				name = name.Substring(0, name.Length - "TextMapHash".Length);
			
			if (transform_hashes) {
				if (name.EndsWith("HashPre"))
					name = name.Substring(0, name.Length - "Pre".Length);
				
				if (name.EndsWith("HashSuffix"))
					name = name.Substring(0, name.Length - "Suffix".Length);
			}
			
			return name;
		}
		
		private IEnumerable<ItemReference> GetAllProperties(TypeDefinition t) {
			var props = new List<ItemReference>();
			
			props.AddRange(
				t.Properties.Where(p => p.SetMethod != null).Select(p => new ItemReference(p, p.PropertyType))
			);
			
			if (t.BaseType != null)
				props.AddRange(GetAllProperties(t.BaseType.Resolve()));
			
			return props;
		}
		
		private IEnumerable<ItemReference> GetAllFields(TypeDefinition t) {
			bool dump = false;
			
			// We only need fields backed up by properties
			var props = new HashSet<string>(t.Properties.Where(p => p.SetMethod != null).Select(p => TransformName(p.Name, true)));
			
			var fields = new List<ItemReference>();
			
			if (dump)
			foreach (var p in t.Fields) {
				Console.WriteLine("{0} {1} {2} {3} {4}", 
				                  //(p.IsPrivate || p.Name.EndsWith("TextMapHash")),
				                  (!p.IsPublic || p.Name.EndsWith("TextMapHash")),
				               !p.IsStatic,
				               !IsNotSerialized(p),
				               props.Contains(TransformName(p.Name)),
				               TransformName(p.Name)
				              );
			}
			
			fields.AddRange(
				//t.Fields.Where(p => (p.IsPrivate || p.Name.EndsWith("TextMapHash")) && // TODO: WTF???
				t.Fields.Where(p => (!p.IsPublic || p.Name.EndsWith("TextMapHash")) && // TODO: WTF???
				               !p.IsStatic && 
				               !IsNotSerialized(p) && 
				               (props.Contains(TransformName(p.Name, true)) || p.Name.IsBeeObfuscated() || p.Name.EndsWith("TextMapHash"))
				              ) // TODO: add obfuscated properties and hope for the best
				.Select(p => new ItemReference(p, p.FieldType))
			);
			
			return fields;
		}
		
		private IEnumerable<TypeReference> GetDerivedClasses(TypeReference t) {
			return assembly.MainModule.Types.Where(x => t.Equals(x.BaseType));
		}
		
		private bool IsNotSerialized(IMemberDefinition def) {
			foreach (var attrib in def.CustomAttributes)
			{
				if (attrib.AttributeType.Name == "NonSerializedAttribute")
				{
					return true;
				}
				
				if (attrib.AttributeType.Name == "AttributeAttribute")
				{
					foreach (var f in attrib.Fields) {
						if (f.Name == "Name" && f.Argument.Value != null && f.Argument.Value.ToString().Equals("CompilerGeneratedAttribute")) {
							return true;
						}
					}
				}
			}
			
			return false;
		}
		
		private string KSGetTypeName(TypeReference t, bool dispatch = false) {
			if (t.IsArray) {
				var arr = t as ArrayType;
				
				return string.Format("ks__array_of__{0}", KSGetTypeName(arr.ElementType, true));
			} else if (t.Resolve().IsEnum) {
				return string.Format("{0}", t.Name.Transform());
			} else if (t.Name.EndsWith("HashSet`1")) {
				// Treat it as an array
				var dt = t as GenericInstanceType;
				var e_type = dt.GenericArguments[0];
				return string.Format("ks__array_of__{0}", KSGetTypeName(e_type, true));
			} else if (t.Name.EndsWith("Dictionary`2")) {
				var dt = t as GenericInstanceType;
				var key_type = dt.GenericArguments[0];
				var value_type = dt.GenericArguments[1];
				return string.Format("ks__dict_of__{0}_{1}", KSGetTypeName(key_type, true), KSGetTypeName(value_type, true));
			} else if (t.FullName.StartsWith("MoleMole.Config.") && dispatch && IsPartOfHierarchy(t)) {
				return string.Format("ks__disp__{0}", td_resolver.GetBasestBase(t).Name.Transform());
			} else {
				return t.Name.Transform();
			}
		}
		
		private bool IsPartOfHierarchy(TypeReference t) {			
			var tr = t.Resolve();
			
			return !tr.IsEnum && 
				(GetDerivedClasses(t).Count() > 0 || (tr.BaseType != null && 
				                                      !tr.BaseType.FullName.Equals(typeof(object).FullName) && // System.Object
				                                      !tr.BaseType.FullName.Equals(typeof(ValueType).FullName) // struct
				                                     )) &&
				!disabled_derivation_classes.Contains(t.Name.Split('.').Last());
		}
		
		private bool IsTopOfHierarchy(TypeReference t) {
			return GetDerivedClasses(t).Count() == 0;
		}
		
		private IEnumerable<ItemReference> RearrangeProperties(IEnumerable<ItemReference> prior) {
			// Fields named "HashSuffix" and "HashPre" come in ExcelConfig file in reverse order to specified in assembly
			var ret = new List<ItemReference>();
			
			var array = prior.ToArray();
			
			for (int i = 0; i < array.Length; ) {
				if (array[i].Name.EndsWith("HashPre")) {
					ret.Add(array[i+1]);
					ret.Add(array[i]);
					i += 2;
				} else {
					ret.Add(array[i]);
					i++;
				}
			}
			
			return ret;
		}
		
		private int Hack_MapBit(int b, string classname) {
			if (classname.Equals("DialogExcelConfig")) {
				// BF transform: 0bJIHG_FEDC_BA98_7654_3210 => 0bJ_IHGF_DA98_7643_210*
				// Address map:  0bGFED_CB**_*A98_7*65_4321
				//b.PushBit(0, 0);
				//b.PopBit(6); //5
				//b.PopBit(11); //10
				//b.PopBit(11); //10
				//b.PopBit(11); //10
				if (b < 6)  return b-1;
				if (b < 11) return b;
				return b+3;
			} else if (classname.Equals("CoopInteractionExcelConfig")) {
				//b.PopBit(1);
				if (b < 1)	return b;
				return b+1;
			} else if (classname.Equals("GadgetExcelConfig")) {
				// BF transform: 0bK_JIHG_FEDC_BA98_7654_3210 => 0bI_HGFE_DCB9_8765_4320
				// Address map: 0bH_*GFE_DCBA_9*87_6543_21*0
				//b.PopBit(1); // 1
				//b.PopBit(9); // 10
				//b.PopBit(17); // TODO: May be 16 or 18? // 18, 19 or 20
				if (b < 1)	return b;
				if (b < 9)	return b+1;
				if (b < 17)	return b+2;
				return b+3;
			} else if (classname.Equals("MainCoopExcelConfig")) {
				//b.PopBit(1);
				if (b < 1)	return b;
				return b+1;
			} else if (classname.Equals("MonsterExcelConfig")) {
				//b.PopBit(2);
				if (b < 2)	return b;
				return b+1;
			} else if (classname.Equals("NpcExcelConfig")) {
				//b.PopBit(19); // TODO: Or 20
				if (b < 19)	return b;
				return b+1;
			} else if (classname.Equals("RefreshIndexExcelConfig")) {
				//b.PopBit(4);
				if (b < 4)	return b;
				return b+1;
			} else if (classname.Equals("WeatherExcelConfig")) {
				//b.PopBit(3);
				if (b < 3)	return b;
				return b+1;
			}
			
			return b;
		}
		
		private void WriteLine() {
			WriteLine("", null);
		}
		
		private void Write(ulong u) {
			Write(u.ToString(), null);
		}
		
		private void Write(byte u) {
			Write(u.ToString(), null);
		}
		
		private void Write(bool u) {
			Write(u.ToString(), null);
		}
		
		private void Write(float u) {
			Write(u.ToString(), null);
		}
		
		private void Write(double u) {
			Write(u.ToString(), null);
		}
		
		private void Write(string format, params object[] m) {
			#if DEBUG
			Console.Write("".PadLeft(level*2) + format, m);
			#endif
		}
		
		private void WriteLine(string format, params object[] m) {
			#if DEBUG
			Console.WriteLine("".PadLeft(level*2) +format, m);
			#endif
		}
	}
}
